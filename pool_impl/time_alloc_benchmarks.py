#!/usr/bin/python3

import subprocess
import os
import matplotlib.pyplot as plt
import numpy as np
import argparse


def generate_table():
    '''
    Generate a table in which each table has the following format:
    ["executable name", "memory usage", "time elapsed",
     "memory usage (as given by the "time" command)"].

    The contents of the table are generated from all the executables whose
    names start with "alloc_benchmark" and that can be found in the folder
    "./build/benchmarks/"
    '''
    folder = './build/benchmarks/'
    # the format string of the "time" command
    time_format = '%e ms\n%M KBs'
    table = []
    for file in sorted(os.listdir(folder)):
        if file.startswith('alloc_benchmark'):
            print(os.path.join(folder, file))
            out = subprocess.run(['time', '-f', time_format,
                                  os.path.join(folder, file)],
                                 stdout=subprocess.PIPE,
                                 stderr=subprocess.STDOUT)
            # check if our benchmark was not killed by the OS
            if out.returncode == 0:
                # "time <alloc_benchmark_#>" will output several lines of
                # interest. The last 3 lines contain the memory usage
                # the time elapsed and the memory usage as reported by
                # the "time" command
                output = str(out.stdout).split('\\n')[-4:-1]
                # append KBs to the 3rd from last line
                output[0] += ' KBs'
            else:
                # the OS might kill the benchmark due to the
                # high amount of allocations made
                output = ['Killed', '', '']
            output.insert(0, file)
            table.append(output)
    return table


def write_table_to_file(table):
    '''
    Write the given table to a file called "time_alloc_benchmarks.output".

    The table can be generated by calling "generate_table".
    Each table entry is written in the following format:
      "----------"
      "name=<exec_name>"
      "proc_mem_usage=<value>"
      "time_taken=<value>"
      "time_cmd_mem_usage=<value>"
    '''
    column = ['name=', 'proc_mem_usage=', 'time_taken=', 'time_cmd_mem_usage=']
    with open('time_alloc_benchmarks.output', 'w') as f:
        for entry in table:
            f.write('-' * 10 + '\n')
            to_write = ''
            for i, elem in enumerate(entry):
                to_write += column[i] + elem + '\n'
            f.write(to_write)


def plot_table(table):
    '''
    Show two barcharts that represent the given table.
    '''
    # x-axis
    objects = []
    # y-axis of the bar chart which represents memory usage
    mem_usage = []
    # y-axis of the bar chart which represents elapsed time
    time = []
    for line in table:
        for index, col in enumerate(line):
            if index == 0:
                objects.append(col.split('_')[-1])
            elif index == 1:
                # it could be that the column has the value
                # "Killed", in which case we return 0
                try:
                    val = int(col.split(' ')[0])
                except:
                    val = 0
                mem_usage.append(val)
            elif index == 2:
                try:
                    val = float(col.split(' ')[0])
                except:
                    val = 0.0
                time.append(val)
    # generate the subplots
    y_pos = np.arange(start=1, stop=len(objects)+1)
    fig, axs = plt.subplots(2, 1)
    ax_info = [{'title': 'alloc_benchmarks memory usage',
                'format': ('%d KBs', int),
                'y_label': 'KBs',
                'data': mem_usage},
               {'title': 'alloc_benchmarks elapsed time',
                'format': ('%.2f ms', float),
                'y_label': 'ms',
                'data': time}]
    for index, ax in enumerate(axs):
        info = ax_info[index]
        bar1 = ax.bar(y_pos, info['data'], align='center', alpha=0.5)
        ax.set_xticks(y_pos, objects)
        ax.set_ylabel(info['y_label'])
        for bar in bar1:
            height = bar.get_height()
            (format, func) = info['format']
            ax.text(bar.get_x() + bar.get_width()/2.0, 1.05*height,
                    format % func(height),
                    ha='center', va='bottom')
            ax.set_title(info['title'])
    plt.show()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description='Run all the alloc_benchmarks'
    )
    parser.add_argument('--output', '-o', help='What type of output is going'
                        ' to be used. Can be "1" for bar chart or "0" for text'
                        'file (default: 0)',
                        default="0")
    args = parser.parse_args()
    table = generate_table()
    if args.output == "0":
        write_table_to_file(table)
    else:
        plot_table(table)
